{"Name":"loss_of_microseconds","Result":false,"SerializedDocument":"<?xml version='1.0' encoding='ASCII'?>\r\n<prov:document xmlns:ex=\"https://example.org/\" xmlns:prov=\"http://www.w3.org/ns/prov#\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\r\n  <prov:activity prov:id=\"ex:a\">\r\n    <prov:startTime>2023-09-08T14:12:45.109312</prov:startTime>\r\n    <prov:endTime>2023-09-08T14:12:45.109321</prov:endTime>\r\n  </prov:activity>\r\n</prov:document>","DeserializedDocument":"<document xmlns=\"http://www.w3.org/ns/prov#\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:prov=\"http://www.w3.org/ns/prov#\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\r\n  \r\n    <activity xmlns:ex=\"https://example.org/\" prov:id=\"ex:a\">\r\n      <startTime>2023-09-08T14:12:45.109Z</startTime>\r\n      <endTime>2023-09-08T14:12:45.109Z</endTime>\r\n    </activity>\r\n  \r\n</document>","Exception":null,"Description":"Python represents the startTime and endTime as datetime.datetime(https://docs.python.org/3/library/datetime.html#datetime-objects)\r\nBecause when creating activity it uses the [_ensure_datetime()](https://github.com/trungdong/prov/blob/1cb710a26c623c5c706b1c6945c645efd9e925c0/src/prov/model.py#L34) function, which uses [dateutil.parser](https://dateutil.readthedocs.io/en/stable/parser.html), on line 36:\r\n\r\n\\` return dateutil.parser.parse(value)\\`\r\n\r\nThe dateutil.parser#parse() method converts microseconds like this:\r\n\r\n\\`int(f.ljust(6, \"0\")[:6]\\`\r\n\r\nwhere \\`f=microseconds\\`. Therefore, the length of microseconds will always be 6 and high precision is lost.\r\n\r\nThis means that microseconds will always be 6 characters long. Therefore, some precision is lost.\r\n\r\nWhen deserializing XML format, Java uses [jackson](https://github.com/FasterXML/jackson) library.\r\nWhen deserializing the startTime and endTime, Java uses default jackson deserializer. \r\nWhen deserializing microseconds, this deserializer uses method protected StdDateFormat#_parseAsISO8601() and this method cuts the microseconds to 3 decimal points. And can do at most 9 digits.\r\n\\`\\`\\`\r\nint msecs = 0;\r\nint fractLen = end - start;\r\nswitch (fractLen) {\r\n    default:\r\n        if (fractLen > 9) {\r\n            throw new ParseException(String.format(\"Cannot parse date \\\"%s\\\": invalid fractional seconds '%s'; can use at most 9 digits\", dateStr, m.group(1).substring(1)), start);\r\n        }\r\n    case 3:\r\n        msecs += dateStr.charAt(start + 2) - 48;\r\n    case 2:\r\n        msecs += 10 * (dateStr.charAt(start + 1) - 48);\r\n    case 1:\r\n        msecs += 100 * (dateStr.charAt(start) - 48);\r\n    case 0:\r\n        cal.set(14, msecs);\r\n}\r\n\\`\\`\\`\r\n\r\nSo we lose high precision here."}